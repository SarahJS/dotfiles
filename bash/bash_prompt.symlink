if ! [ -z ${BASHDEBUG+x} ]; then
    stime_bash_prompt=$(gdate +%s.%N)
    echo "[EXECUTING .bash_prompt]"
fi

    nocol="\[\033[m\]"
    black="\[\033[0;30m\]"
     blue="\[\033[0;34m\]"
    green="\[\033[0;32m\]"
     cyan="\[\033[0;36m\]"
      red="\[\033[0;31m\]"
   purple="\[\033[0;35m\]"
    brown="\[\033[0;33m\]"
  lt_grey="\[\033[0;37m\]"
  dk_gray="\[\033[1;30m\]"
  lt_blue="\[\033[1;34m\]"
 lt_green="\[\033[1;32m\]"
  lt_cyan="\[\033[1;36m\]"
   lt_red="\[\033[1;31m\]"
lt_purple="\[\033[1;35m\]"
   yellow="\[\033[1;33m\]"
    white="\[\033[1;37m\]"

_USER=""
if [[ "$EUID" -ne "0" ]]; then  # if user is not root
    # if user is not login user
    if [[ $USER != "$(logname 2>/dev/null || echo $LOGNAME)" ]]; then
        _USER="$lt_grey"
    else
        _USER="$cyan"
    fi
else # root!
    _USER="$lt_cyan"
fi
_USER+="\u$nocol"

connection_type() {
    if [[ -n "$SSH_CLIENT$SSH2_CLIENT$SSH_TTY" ]]; then
        echo ssh
    else
        # TODO check on *BSD
        local sess_src="$(who am i | sed -n 's/.*(\(.*\))/\1/p')"
        local sess_parent="$(ps -o comm= -p $PPID 2> /dev/null)"
        if [[ -z "$sess_src" || "$sess_src" = ":"* ]]; then
            echo lcl # Local
        elif [[ "$sess_parent" = "su" || "$sess_parent" = "sudo" ]]; then
            echo su  # Remote su/sudo
        else
            echo tel # Telnet
        fi
    fi
}

case $(connection_type) in
ssh)
    mark="⇝" ;;
tel)
    mark="⇢" ;;
*)
    mark="@" ;;
esac
unset connection_type

# If we are connected with a X11 support
if [[ -n "$DISPLAY" ]]; then
    mark="$white$mark$nocol"
else
    mark="$lt_grey$mark$nocol"
fi

function set_prompt() {
    # get return code of last cmd
    local -i err=$?

    if ! [ -z ${BASHDEBUG+x} ]; then
        stime_bash_prompt_set_prompt=$(gdate +%s.%N)
        echo "[EXECUTING set_prompt]"
    fi

    local cmd_info=""
    if (( err != 0 )); then
        cmd_info="$red$err ↩$nocol \n"
    fi

    local venv=""
    if [[ -n "$VIRTUAL_ENV" ]]; then
        venv=" (⊙${VIRTUAL_ENV#$WORKON_HOME/}) "
    fi

    local writable=":"
    if [[ -w "$PWD" ]]; then
        writable="$green$writable$nocol"
    else
        writable="$red$writable$nocol"
    fi

    local gitbranch="$(git rev-parse --abbrev-ref HEAD 2> /dev/null)"
    if [[ -n "$gitbranch" ]]; then
        gitbranch=" (±$gitbranch)"
    fi

    PS1="$cmd_info$_USER$mark$green\h$nocol$writable$yellow\w$nocol$gitbranch$venv\n$ "

    # Add stuff to path
    # this is slower than I want to deal with
    #if command -v npm >/dev/null 2>&1
    #then
    #    PATH="$PATH:$(npm bin)"
    #fi

    if ! [ -z ${BASHDEBUG+x} ]; then
        etime_bash_prompt_set_prompt=$(gdate +%s.%N)
        echo "[EXECUTED set_prompt ($(echo "$etime_bash_prompt_set_prompt - $stime_bash_prompt_set_prompt" | bc)s)]"
    fi
}

#simple prompt
#export PROMPT_COMMAND=""
#export PS1="\u@\h:\w\n$ "

# update_terminal_cwd is for autojump
if [ -n "$(type -t autojump_add_to_database)" ] && [ "$(type -t autojump_add_to_database)" = function ]
then
    export PROMPT_COMMAND="set_prompt; update_terminal_cwd; autojump_add_to_database"
else
    export PROMPT_COMMAND="set_prompt"
fi

export CLICOLOR=1
export LSCOLORS=ExFxBxDxCxegedabagacad

if ! [ -z ${BASHDEBUG+x} ]; then
    etime_bash_prompt=$(gdate +%s.%N)
    echo "[EXECUTED .bash_prompt ($(echo "$etime_bash_prompt - $stime_bash_prompt" | bc)s)]"
fi

